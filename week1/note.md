# Linux编程

## 第一章UNIX导论

### 1. UNIX简史

贝尔实验室K.Thompson于1969年在小型计算机上开发UNIX系统。

是一种多用户、多任务操作系统。

DennisRitchie开发出C语言

加州大学伯克利分校于1974年12月得到了第一个UNIX许可。在随后几年中，贝尔实验室研究组的一些成员，包括Ken Thompson，利用休假在那里讲授UNIX，并参加一些研究工作。加州大学伯克利分校的甚多研究生和教授对UNIX系统产生了极大的兴趣，其中包括Bill Joy和Chuck Holey。他们为这个UNIX开发了一些实用程序，包括Pascal编译器和ed编译器，这个编译器后来成为著名的vi编译器。

伯克利小组对UNIX作出了许多重要性的贡献。除了虚拟内存和纳入了TCP/IP协议外，BSD UNIX还引入了快速文件系统、可靠信号以及套接字功能。

### 2. Linux简史

1991年芬兰 赫尔辛基大学 学生 Linus Torvalds

尽管Linux有自己的一些特殊功能，但本质上同其他UNIX的商业版本一样，也是UNIX的一种实现，它与绝大多数UNIX标准兼容。这意味着只要遵循UNIX标准书写程序，在Linux上便可以不加修改的运行。

### 3. UNIX基本概念

#### 3.1 程序

程序：程序是包括计算机要执行指令集合的文件，它分为源程序和可执行程序。

UNIX系统还有另一种可执行程序：shell脚本程序，例如用sh编写的脚本程序。

#### 3.2 进程

进程：

​	从用户的角度看，进程是程序的一个运行实例。

​	从UNIX系统内部来看，进程是运行程序并未运行程序提供运行环境的实体，是系统进行资源分配和调度运行的一个独立单位。

进程有以下三个特点：

1. 进程有一个控制点和自己的独立的地址空间。
   
2. 进程具有生存期。（新建、就绪、运行、阻塞、僵死）
   
3. 处于运行状态的进程有两种执行状态：用户态和核态。

#### 3.3 内核

内核：

​	硬件包括CPU、存储器、硬盘以及其他设备。

​	对硬件进行管理的软件叫操作系统，在UNIX术语中成为UNIX内核。在Linux中，内核驻存名为 /root/vmLinux 的磁盘文件中。
![](http://117.78.7.207:6789/imgs/2020/10/902e76543db7055a.png)

#### 3.4 shell

   UNIX内核虽然负责管理和创建程序，但它并不执行用户输入的命令。用户输入的命令由shell来执行。

#### 3.5 用户名和用户ID 用户组名和组ID

​	UNIX中的每一个用户有一个账号,该账号有一个用户名和一个唯一的用户ID。用户名也称为注册名,它是一个字符串:用户ID是一个整数。用户在登录时通过用户名向系统标识自己,用户ID则主要用于检测该用户是否有某项操作的权限。

​	UNIX系统中,用户可以组织成组,一个用户可以是一个或多个组的成员,其中一个组是用户的初始组,简称为组。如果该用户还属于其他组,则这些组称为该用户的附加组。用户组是由系统管理员建立的,系统文件 etc/group中登记了系统中存在的所有组和组I,以及组内的用户。

​	口令文件etc/ passwd记录了系统中的所有注册用户,每一个用户有一个登记项,其中包含用户名、用户ID、用户的组ID等信息,其中,用户的组ID指明了该用户的初始组。

#### 3.6 特权用户

​	特权用户的用户名是root,其用户ID是0。UNIX内核识别用户ID为0的用户并允许他不受限制地做任何事情,他可以超越系统施加的所有文件访问和执行权限。更重要的是,特权用户有控制整个系统的权力,如关闭系统,甚至不经意地用一条简单的命令破坏整个系统!

​	正由于特权用户具有这种特殊的权力,因此,能够以特权用户身份访问系统的人必须知道自己所做的事情。特权用户具有监管系统运行、维护系统安全、配置系统、增加和删除用户以及对系统进行正常备份等责任。除了特权用户之外,UNIX内核不区分其他任何用户,其他所有用户都视为是同等的,并且只能够做权限许可之内的事情。

#### 3.7 系统调用和库函数

​	系统调用总是在《UNIX程序员手册》的第2部分中说明,而通用库函数则总是在第3部分中说明。因此,UNIX约定用函数名后随“(2)”表示系统调用,“(3)”表示库函数。例如,read(2)表示read是系统调用,而 printf(3)则表示 printf是库函数。

#### 3.8 系统库

​	系统库给应用程序提供编译好的标准函数和系统调用函数的目标代码，这些代码在连接时与应用程序的目标代码装配在一起形成一个完整的可执行程序。

​	C标准库不仅包含了C标准规定的函数(不包括科学计算函数以及国际化和宽字符函数),而且包含了POSIX标准定义的大部分编程接口函数。当我们编译C源程序时,编译器会自动地连接C标准库。但是,如果程序中调用了其他库中的函数,则在编译时要指定连接相应的库。如果不指定它们的话,连接程序会报未定义的函数错误。

​	Linux中系统库位于`usr/lib`以及其子目录中。

##### 3.8.1 头文件

​	库由两部分组成：头文件和实际的库。

​	头文件通过`#include`预处理命令包含于源文件中。C语言支持两种形式的指导命令，

第一种是：

​	`#include "header"`

这种用双引号包括起来的头文件一般是程序员自己编写的。header可以是任意正文文件。

第二种是：

​	`#include <file.h>`

这种形式用于包含系统提供的头文件,它含有系统库中函数的定义和说明,这个文件通常由系统管理员放置在一个标准位置。 Linux中它们一般位于目录`/usr/include`以及其下的子目录中。对于标准库调用,应当使用第二种形式。

##### 3.8.2 保留字

​	保留字是系统专门保留使用权并有特定含义的名字。C标准库中所有 ANSI C标准中的类型名、宏名、变量名和函数名都无条件地是保留字。所有其他的库名字,如果源程序中明显包含了定义或说明它们的头文件,则这些名字也是保留字。

​	除了标准定义的类型名、宏名、变量名和函数名之外,UNX系统也约定,所有以一个下划线符('_')开头的外部标识符(全局函数和变量)、所有以两个下划线符('__',注意,由于印刷的原因常常会使得两个下划线符看起来像一个长下划线符)开头或以一个下划线符后随个大写字母开头的标识符均是保留字。这个约定使得库和头文件能够为内部目的定义函数、变量和宏名字而不会与用户程序中的名字相冲突。

##### 3.8.3 特征测试宏

#### 3.9 系统信息

函数`gethostname()`和`sethostname()`可以用来获取和设置主机名。

````C
#include <unstd.h>
int gethostname(char* name,size_t size);
int sethostname(const char* name,size_t length);
````

​	gethostname()返回以NUL(\0)字符结束的主机名于字符数组name之中,参数size给出此数组的字节大小。当size指定的空间不足以存放主机名时, gethostname()存储截断了的主机名至name,并且返回-1。此时,应当用一个更大的数组重新调用该函数。 POSIX规定主机名的字符个数不超过系统符号常数 HOST_NAME_MAX之值, Linux定义其值为64字节.

​	sethostname()设置主机的名字为name,name是一个长度为 length的字符串。只有特权进程才允许调用此函数,通常它只在系统自举时调用一次。

函数`uname()`可用来查看运行该程序的计算机操作系统版本和硬件信息。

````C
#include <sys/utsname.h>
int uname(struct utsname *info);
````

​	uname()是一个系统调用,成功时返回非负整数,同时将操作系统和主机的信息保存在info所指的数据结构中;失败则返回-1。其中 utsname结构类型的成员如表1-2所示。utsname成员的长度与特定的实现有关。有的实现使用固定数值常数,有的实现则使用符号常数,如 UTSLEN或 UTSNAME LENGTH等。不过当我们希望获得 uname()返回的这些成员的有效数据长度时,最好由 sizeof()来确定。

表1-2 utsname结构成员

| 成员            | 描述                         |
| --------------- | ---------------------------- |
| char sysname[]  | 操作系统名称                 |
| char nodename[] | 计算机的主机名               |
| char release[]  | 操作系统的当前版本号         |
| char version[]  | 操作系统的当前版本号的级别号 |
| char machine[]  | 描述使用的硬件类型           |

##### 3.9.1 限制值

​	静态限制值是编译时的限制,它们总是定义在头文件< limits.h>中。例如,关于数据类型的限制值多数是C标准的限制,相对于任何一个特定的系统,它们都是固定不变的且可以作为#if预处理指导命令中的常数表达式。

​	对于运行时的限制值,它们的宏名仅当系统有固定不变的限制值时才定义在< limits. h>中,如果在< limits. h>中没有定义,则必须在运行时调用系统提供的 sysconf()、 pathconf()或fpathconf()三个函数之一来确定它们的运行值。对于那些可能是不确定的限制值,当没有定义时,这三个函数会返回-1。

##### 3.9.2 系统和文件特征选项

​	除了上ー小节介绍的限制值之外,UNIX系统还有另外一些关于系统能力的选项,它们表示的不是资源的限制值而是系统是否具有某种能力或提供某种功能,这种能力是UNIX标准允许的可选特征。

​	UNIX标准涉及的特征选项有许多,对于每一种选项相应地有一个选项宏名字。我们这里仅介绍它们之中的几个,其他的选项可査阅< unistd. h>头文件或 syscon)、 pathconf0和fpathcont0函数的联机说明。

##### 3.9.4 sysconf()、pathconf()、fpathconf() 函数

​	对于运行时的限制值和选项,我们已经知道可以用 sysconf()、 pathconf()和 fpathconf()用于获得与文件或目录无关的限制值,以及系统特征选项; pathconf()和 fpathconf()用于获得与文件或目录有关的限制值。这三个函数的原型为:

````C
#include <unistd.h>
long int sysconf(int parameter);
long int pathconf(const char *pathname,int parameter);
long int fpathconf(int filedes,int parameter);
````

​	sysconf()用于确定当前的系统变量之值(即限制值和特征选项),其中参数 parameter指出要询问的是哪个系统变量,它应当是头文件< unistd. h>中定义的以'\_SC\_'开头的符号常数之,表1-3列出了其中的一部分。

表1-3 sysconf() 的 parameter 参数使用的符号常量
![](http://117.78.7.207:6789/imgs/2020/10/7899ce0bfd1ad346.png)

​	该函数调用成功将返回所询问参数之值,这个值在调用进程的生存期内不会改变。如果parameter参数不合法, syscon返回-1并设置erno指出错误。如果系统不支持所询问的参数或者所询问的限制值不确定, sysconf()返回-1但不设置erno。

​	因为-1既是正常返回值也是异常返回值,因此,希望检査错误情形的应用在调用它们之前应当先设置 errno为0。如果返回值为-1,则通过检查erno是否为非0来判别错误。

​	另外,建议首先用特征测试宏检查你感兴趣的宏名是否有定义并且仅当它没有定义时才调用 sysconf(),这样做可使程序更有效率。



​	函数 pathconf()和 fpathconf()作用相同,它们都用于查询与文件系统限制和选项有关的值,不同的只是 pathconf()作用于文件名 pathname,而 fpathconf()作用于已打开的文件描述字 filedes。参数 parameter必须是定义在头文件< unistd.h>中以'\_PC\_'开头的符号常数之表1-4列出了其中的一部分。

![](http://117.78.7.207:6789/imgs/2020/10/885c8a1d9b15ddda.png)

​	这两个函数调用成功返回所査询参数之值。如果系统不施加限制或者当有错时,返回值为-1。在前一种情况下不设置errno,在后一种情况下设置errno指明错误原因。因此,同sysconf()一样,可靠调用这两个函数的方法是在调用它们之前将errno清零。

### 4. 其他知识


#### Linux操作系统主要有以下几个特点：

1. 不限制应用程序可用内存的大小；

2. 具有虚拟内存的能力，可以利用硬盘来扩展内存：

3. 允许在同一时间内，运行多个应用程序；

4. 支持多用户，在同一时间内可以有多个用户使用主机；

5. 具有先进的网络能力，可以通过TCP/IP协议与其他计算机连接，通过网络进行分布式处理；

6. 符合Unix标准，可以将 Linux上完成的程序移植到Unix主机上去运行；

7. Linux操作系统是免费软件，并且开放源代码，这是其与其他网络操作系统最大的区别
