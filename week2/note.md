# Linux编程

## 第二章 标准输入输出

### 1. UNIX输入输出基本概念

​	UNIX系统有两种机制用于描述程序与文件的这种连接:一种称为文件描述字,另一种称为流。因此,系统中关于I/O的函数也分为两大类:一类针对文件描述字操作,另一类针对流操作。

#### 1.1 文件描述字与流

​	UNIX系统中,文件描述字表示为int类型的对象,而流表示为指向类型为FILE结构的指针。文件描述字函数多数是系统调用,它们提供底层基本的输入输出操作接口。当需要对特定设备进行控制操作时,往往必须使用文件描述字,流函数不能够进行这类操作。另外,如果程序需要按特殊方式进行输入输出(如非阻塞输入),也必须使用文件描述字。

​	流函数建立在文件描述字之上,通过文件描述字函数而实现,它给程序提供了更高一级的输入输出接口。流函数比对应的文件描述字函数更丰富,功能更强大,也更利于程序的移植。任何运行 ANSI C的系统均支持流,但并不是所有系统都支持文件描述字,有的系统根本不支持文件描述字或仅仅实现了文件描述字函数集合的一个子集。因此,一般情况下,应当坚持使用流而不是文件描述字,除非是想做某种特殊操作,而此操作只能用文件描述字才能完成。

#### 1.2 文件名和路径名

​	UNIX系统中几乎每一种对象都表示为文件,不仅是通常的数据集合,系统中的每一个设备也表示为文件。文件被安排在目录中,目录本身又含有子目录,由此形成了文件系统的层次结构。

​	目录本身也是一种文件,不过它的内容是一组连接实际文件的文件名及相关信息,这些连接称为链或目录登记项。我们前面虽然说“文件被安排在目录中”,但是实际上目录只包含指向文件的指针而不是文件本身。为了理解文件名的语法,首先需要理解UNIX文件系统的目录层次结构。

​	系统中,每一个用户均有一个主目录,其文件通常存储在这个目录以及该目录的子目录中。例如,用户` kjzhao`,他的主目录是`home/ rizhao`,在其主目录中有系统帮助建立的几个标准目录,如 `bash_profile`等:也有由他自己创建的子目录,如用于日常工作的目录`work`,用于应用程序的目录 `program`等。另外一些用户的主目录也可能位于`/home`目录中,而`home`则是根目录“/”的子目录。在根目录中通常还包括用于系统程序的子目录`/bin`,用于系统配置文件的子目录`/etc`,用于系统库文件的子目录`/lib`,以及代表各种物理设备的子目录`/dev`等。图2-1是这种目录层次的一个示例图。

![](http://117.78.7.207:6789/imgs/2020/10/c69d1394fb49aeeb.png)

​	文件名用于命名一个文件,它由1至 NAME MAX个字符组成,这些字符可以是字符集中斜线字符(/)和空字符(`NUL`)之外的任意字符。系统宏 NAME_MAX是 `POSIX`定义的文件名的最大字符个数(不是字符串的长度,该计数不包括结束的空字符)。

​	文件名也称为路径名分量。路径名用于标识一个文件,它是由1至 PATH_MAX个字符组成的字符串。路径名由用斜线“/”分隔的一至多个路径名分量构成的序列组成。路径名开始的斜线是可选的,仅由一个分量构成的路径名标识一个相对于当前目录的文件,多个连续的“/”字符等价于单个“/”字符。

#### 1.2 文件位置

​	对于已打开的文件,它的属性之一是文件位置。文件位置给出文件中当前可读写字符的位置,在所有 `POSIX`兼容的系统中,它是一个表示距文件开始多少字节数的整数。

​	当文件刚打开时,文件位置位于文件的开始处,之后每当读出或者写入一个字符,文件的位置便增加一字节。换言之,对文件的访问是顺序的。

​	但是,对于以“添加”( append)打开的文件,其写出的处理有点魂对这种文件的写出总是顺序地附加在该文件的末尾,而不管文件的位置如何。其文件位置只用于控制从文件读出数据。

​	普通文件允许读写文件的任意位置。这种允许读写任意位置的文件也称为随机文件。可以用函数` fseek()`或 `lseek()`改变随机文件的位置。如果企图改变一个不支持随机访问的文件的位置,则会得到` ESPIPE`错误。磁盘文件一般均是随机文件,终端则不是随机文件。



### 2. 打开和关闭流

标准流

​	UNIX系统中每个进程都有三个预先定义并自动打开的流，它们是：`stdin,stdout,stderr`。这三个标准流在`<stdio.h>`中说明，分别代表标准输入、标准输出以及错误输出。

以下函数用于打开和关闭一个流

```C
#include <stdio.h>
FILE * fopen(const char *pathname,const char *opentype);
int fclose(FILE *stream);
FILE * freopen(const char *pathname,const char *opentype,FILE *stream);
```

​	`fopen()`打开由 pathname指定的文件并创建一个与之相连的流。如果该文件不存在,则创建一个新文件。如果打开文件成功,它返回指向此流的指针,否则返回空指针NULL。

​	`opentype`参数是一字符串,它控制文件打开的方式,其值只能是下述字符串之一:

- "r":为读而打开一个已存在的文件,文件位置定位于文件开始。

- "w":为写而打开一个文件。如果文件存在,则将它的长度截为0,也即文件将被重新写过;如果文件不存在,则创建一个新文件

- "a":为在文件尾添加内容而打开文件。若文件存在,原来的内容不变且输出添加在文件的末尾;否则,创建一个新文件。

- "r+":为更新(既读又写)而打开一个已存在的文件,文件原有内容不变,文件位置定位于文件开始。

- "w+":为更新(既读又写)而打开一个文件,若文件已存在,其长度被截至0:否则,创建一个新文件。

- "a+":为更新(既读又写)而打开一个文件,若文件已存在,原内容不变:否则,创建一个新文件。用于读的初始文件位置定位于文件开始,但输出总是添加在文件的末尾。

  其中,字母r、w和a分别代表read、 write和 append。字符“+”指明为更新而打开一个文件,当以这种方式打开一个文件时,对它既可写也可读。

打开的流用`fclose()`来关闭。`flcose()`调用成功返回0，否则返回`EOF`并置`errno`指明错误。

​	当调用` fclose()`关闭一输出流时,对错误情形进行检査很重要,因为此时可能检测到真实的错误。例如,当` fclose()`将缓冲区中剩余的数据写出时,它可能得到磁盘空间已满的错误,如果不检测的话,就有可能丢失文件的内容。

​	`freopen()`重新打开 pathname指定的文件,它的作用类似于 `fclose`()和 `fopen()`的合并。如果 stream指定的流是打开的,它首先关闭该流,忽略任何错误,然后按 `opentype`所给方式如同`fopen()`一样打开参数 pathname指定的文件,并使之与 `stream`给定的同一个流相连。 `freopen()`调用成功返回指向流的指针,否则返回NULL并置`errno`指明错误。

​	`freopen()`一般用于连接标准流 `stdin、 stdout、 stderr`至一个我们选择的文件。它对那种难以对标准流进行编程的程序很有用

### 3. 读和写流

​	一旦打开了一个流,就能对它进行读写,读写可以按无格式方式也可以按有格式方式进行。这一节介绍无格式I/O函数,下一节介绍有格式I/O函数。

​	有以下三种类型的无格式IO函数可供选择:

1)字符I/O函数。这种函数每次读或写一个字符。

2)行I/O函数。这种函数每次读写一行,每一行以换行符结束。

3)块I/O函数。这种函数支持成块IO,它们每次读写若干个对象,每个对象的大小是指定的。块IO有时也称为二进制I/O、对象O或结构IO。

#### 3.1 字符I/O

如下三个字符输入函数每次读入一个字符：

```c
#include <stdio.h>
int fgetc(FILE * stream);
int getc(FILE * stream);
int getchar(void);
```

​	`fgetc()`从流 stream中按 unsigned char类型读取下一字符,并将它强制为int类型返回,若遇到文件结束或者出现错误,则返回`EOF`。

​	`getc()`的功能与 `fgetc()`相同,不同的是允许将 `getc()`作为宏来实现,而 `fgetc()`则必须为函数。` getc()`常常是被高度优化了的,因此是最常用的读单个字符的函数。

​	`getchar()`等价于`getc(stdin)`。

​	这三个函数之所以将流中的字符视为 unsigned char,是为了保证在其高位被设置时函数的返回值不会为负值。要求返回值为int类型是为了能够返回所有可表示的字符,不仅是ASCII字符集中的字符,也包括宽字符集中的字符,还包括遇到文件结束和错误时的指示符`EOF`。这意味着我们不能将` fgetc()`的返回值存储在字符类型的变量中。

​	与三个字符输入函数对应有如下三个字符输出函数:

```c
#include <stdio.h>
int fputc(int c,FILE *stream);
int putc(int c,FILE *stream);
int putchar(int c);
```

​	`fputc()`将字符c转换为 unsigned char类型,然后写至流 stream并返回字符c。`putc()`与 `fputc()`相同,但它常常是用较快的宏来实现的。 `putc()`是用于输出单个字符最合适的函数。类似于输入函数, `putchar()`等价于`putc(stdin)`

#### 3.2 行I/O

##### 3.2.1 行I/O输入

标准C库有两个函数用于每次读入一行：

```C
#include <stdio.h>

char * fgets(char *s,int count,FILE *stream);
char * gets(char *s);
```

​	`fgets()`从 stream指定的流中连续读字符直至读到换行符或者读够count-1个字符(包括换行符)为止,读入的这一行字符(包括最后的换行符)存储在参数s指定的字符串中,并且在其末尾添加一个空字符(\0)作为结束。参数count指明字符串s的大小。

​	如果要读入的这一行(包括结尾的换行符)长度大于count-1,则只有部分字符被读入,而字符串s总是以空字符结尾,下一次调用 `fgets()`将返回此行剩余的部分。

​	`gets()`函数从标准输入流` stdin`中读入完整的一行至参数s指定的字符串中。它删除换行符并在字符串s的末尾添加一个空字符作为结束。

​	注意`gets()`与` fgets()`的不同。 `fgets()`不能保证一定读入完整的一行,因此为了判别是否已经读入一行,它需要保留换行符,而`gets()`则无此需要,故它删別除换行符。另外,由于`gets()`不要求提供字符串s的空间大小,这导致`gets()`成了危险的函数:它没有为字符串s的溢出提供保护!当要读入的行长度超过字符串s所能容纳的大小时,超出的部分将越过。s提供的空间而覆盖其他的数据或程序。因此最好不要使用`gets()`。

​	如果调用这两个函数时文件已处在文件尾,则字符串s不发生改变且返回值都是`EOF`。这两个函数遇到错误时也返回`EOF`,正常情况下返回指向字符串s的指针。

​	Linux中的`GNU C`库为此专门提供了另外一个毎次读一行的函数 `getline()`,此外还扩充了个更通用的类似函数 `getdelim()`,该函数读入一被界定的记录,这种记录定义为直至下一特定分隔符为止的所有内容。

```c
#include <stdio.h>

ssize_t getline(char **lineptr,size_t *n,FILE *stream);
ssize_t getdelim(char **lineptr,size_t *n,int delimiter,FILE *stream);
```

​	`getline()`从流 `stream`中读入一行(包括换行符和一个终止空字符),并存储于`*lineptr`所指缓冲区中,缓冲区的大小由参数`*n`给出。

​	在调用 `getline()`之前一般先要调用 `malloc()`分配大小为`*n`个字节的缓冲区,并存放其地址于`*lineptr`。如果这个缓冲区的大小足够容纳输入行, `getline()`将此行置于缓冲区中。否则, `getline()`会自动扩大此缓冲区,然后将新缓冲区的地址回填至`*lineptr`,新增加后的缓冲区大小存回至`*n`。特别地,当`*lineptr`为空指针,`*n`为0时, `getline()`会自动分配初始缓冲区。

​	`getline()`调用成功的返回值是读入的字符数(包括换行符,但不包括终止空字符),这使我们能够区分行中的空字符和作为终止符的空字符:终止空字符所在的位置一定等于 `getline()`的返回值。

​	函数 `getdelim()`类似于 `getline()`,不同的只是作为行终止的分隔符不一定是换行符,而可以通过参数 `delimiter`指定,`getline()`一直读至遇到该字符或文件结束为止。读入的正文包括该分隔符和一个终止的空字符。

​	实际上，`getline()`是用`getdelim()`来实现的：

```c
ssize_t getline (char **lineptr,size_t *n,FILE *stream)
{
    return getdelim(lineptr,n,'\n',stream);
}
```

##### 3.2.2 行I/O输出

​	每次输出一行可以用`fputs()`或`puts()`函数。

```c
#include <stdio.h>

int fputs(const char *s,FILE *stream);
int puts(const char *s);
```

​	`fputs()`输出以空字符结尾的字符串s至流 `stream`,但结尾的空字符不写入,也不添加换行符,它只输出字符串中的字符。如果发生错误,该函数返回`EOF`,否则返回一非负值.

​	`puts()`输出以空字符结尾的字符串s至标准输出流 `stdout`并添加一个换行符,但字符串结尾的空字符不写出。注意它与 `fputs()`的不同:` fputs()`不添加换行符,而 puts则添加换行符。

#### 3.3 读回退

​	程序在读输入的过程中,有时候会只想查看一下输入流中的下一字符而并不想将它从输入流中读走,这称为对输入流的超前窥视,因为程序只是对下次要读入的字符提前看一眼。在流I/O的情况下,只能通过首先从流中读出字符,然后再将该字符退回至输入流来实现超前窥视。回退字符至流的函数是`ungetc()`,它是`getc()`的逆操作

```c
#include <stdio.h>
int ungetc(int c,FILE *stream);
```

​	`ungetc()`将字符c退回至输入流 stream。于是下一次从 stream的输入将首先读到字符c。若调用成功,该函数返回回退的字符,否则返回`EOF`。

​	如果要回退的字符c是`EOF`, `ungetc()`不做任何动作并返回`EOF`,这使得我们在使用`getc()`的返回值调用 `ungetc()`时无须对 `getc()`的错误进行检测。

​	大多数系统都只支持回退一个字符, Linux也如此。这意味着连续两次调用 `ungetc()`之间必须有一次读入。如果在未调用 `getc()`的情况下再次调用 `ungetc()`将使前一个回退的字符丢失。

​	回退字符并不是将字符送回文件本身,而是送回流的内部缓冲中。因此,如果调用了一个文件定位函数如`fseek()`或 `rewind()`,则将丢弃任何未重新被读入的回退字符。

#### 3.4 块I/O

​	块I/O也称为二进制I/O,它以固定大小的块为单位而不是以字符或行为单位来读写数据。要读写的数据既可以是字符正文,也可以是二进制数据。函数`fread()`和`fwrite()`用于进行这种成块的输入输出。

```c
#include <stdio.h>
size_t fread(void *data,size_t size,size_t count,FILE *stream);
size_t fwrite(const void *data,size_t size,size_t count,FILE *stream);
```

​	`fread()`从流 stream中读 count个数据项,并存放至data所指的数组中,每个数据项的长度为size字节,所读的总字节数为`count X size`。

​	`fwriter()`从data所指的区域中写出 count个数据项至流 stream,每个数据项的长度为size字节,所写出的总字节数为`count X size`。

​	`fread()`和`fwrite()`均返回实际读写的数据项数(注意,不是字节数)。若调用成功,返回值等于count;若遇到文件尾或错误,返回值小于 count或为`EOF`;当出现错误时,设置`errno`指明错误原因:如果 count或size为0,则不做任何动作并返回0。

### 4. 文件定位

​	标准I/O库提供了如下两组对随机文件进行定位的函数，用它们可以随机的读写文件的任何部分。

```c
#include <stdio.h>

long int ftell(FILE *stream);
int fseek(FILE *stream,long int offset,int whence);
void rewind(FILE *stream);

int fgetpos(FILE *stream,fpos_t *pos);
int fsetpos(FILE *stream,const fpos_t *pos);
```

​	`ftell()`调用成功返回 stream指定流的当前文件位置,它是从文件开始的字节数;否则返回-1并置`errno`

​	`fseek()`改变流stream的文件位置。具体位置由参数 offset和 whence指定。 offset给出相距由 whence给出的起点的字节偏移,它可以是正数,也可以是负数。 whence指定起点,起点可以是文件开始、文件尾或者当前文件位置,具体为下述值之一:

- SEEK_SET:  文件位置定位于文件开始+offset之处，此时offset不能为负数。

- SEEK_CUR: 文件位置定位于文件当前位置+offset之处。

- SEEK_END: 文件位置定位于文件尾+offset之处。

​	`fseek()`调用成功返回0,失败返回非0。如果调用成功,它将清除流的文件结束指示器并忽略由`ungetc()`退回的字符。如果是输出流并且缓冲的数据还未写至相连的文件, `fseek()`将导致未写出的数据被写至文件。因此,对于以更新方式(“+”)打开的文件,调用`fseek()`之后,在此文件上的下一个操作既可以是输入,也可以是输出。

​	rewind()定位流seam于文件的开始,其作用等价于`fseek(stream,0L,SEEK_SET)`,不同的是它无返回值且重置了流的错误指示器。

​	`fgetpos()`和`fsetpos()`是 ANSI C新补充的,它们比`ftell()`和`fseek()`的兼容性更好。这两个函数引入了一个新的抽象类型 fops_t来表示文件位置。在`POSIX`兼容的系统中,这个类型通常就是长整型,但在其他系统中则可能有不同的内部表示。例如在有的系统中,文件位置必须同时用文件内的记录位置和记录内的字符偏移来表示。因此,如果想使程序可以移植至这种系统,最好使用函数`fgetpos()`和`fsetpos()`。

​	`fgetpos()`获取流 stream的当前文件位置并将其存储在`pos`指定的对象中。

​	`fsetpos()`用`pos`给出的值设置流 stream的文件位置。`pos`给定的值必须是前面对同一个流调用 `fgetpos()`而得到的。如果成功,`fsetpos()`将清除文件结束指示器并忽略由`ungetc()`退回的任何字符。

### 5. 文件结束和错误指示器

​	本章的多数函数`(fgets()、 gets()、 putc()、 ungetc()、 fread()等)`当调用不成功时都返回`EOF`,`EOF`的值为0,它既用于报告文件结束,也用于报告错误情形下的返回。因此,为了区分究竟是错误返回还是文件结束返回,就需要调用 `ferror()`函数来确定是否存在错误,调用`feof()`函数检查是否遇到文件结束。每一个流对象内部有两个指示器:一个为错误指示器,当读写文件出错时该指示器被设置另一个为文件结束指示器,当遇到文件尾时该指示器被设置。函数`ferror()`和`feof()`分别检查这两个指示器。

```c
#include <stdio.h>

int ferror(FILE *stream);
int feof(FILE *stream);
void clearerr(FILE *stream);
```

​	函数`ferror()`返回0当且仅当流 stream的错误指示器被设置`feof()`返回0当且仅当流 stream的文件结束条件指示器被设置。函数 clearer用于清除这两个指示器。对流进行操作的函数除了设置与流相连的错误指示器外,也设置全局变量`errno`。

### 6. 流缓冲

1. 全缓冲。在这种情况下,真正的I/O操作每次以整个缓冲区为单位读写数据,缓冲区的大小一般为`BUFSIZ`。对于输出,只有当缓冲区满了时才传送它至文件;对于输入,每次从文件读入数据直至缓冲区满为止。磁盘文件一般是全缓冲的。

2. 行缓冲。在这种情况下,仅当在输入或输出中遇到换行符时才执行真正的O操作。行缓冲一般用于终端之类交互设备的流。例如,如果我们用`fputc()`输出15个非换行字符,然后输出一个换行符,则只有当最后这个输出换行符的`fputc()`(被调用后,前面输出的15个字符才能真正出现在终端上。

3. 无缓冲。流不设置缓冲区，字符单个的读出或写入。

   UNIX系统对新打开的流采用如下缓冲类型：

   - 标准错误流总是无缓冲的。这是为了使错误信息能及时显示出来。这意味着如果用`fputc()`输出15个字符至代表错误流的终端，则每一个字符都将在函数被执行后立即出现在终端。
- 其他的流若引用交互设备则是行缓冲的，否则是全缓冲的。
#### 6.1 设置缓冲

   这种自动默认选择给予输入输出文件或设备一种最方便的缓冲方式。不过,如果不满意这种默认缓冲的话,也可以用如下函数设定自己的缓冲区及希望的缓冲类型和大小。

```c
#include <stdio.h>

void setbuf(FILE *stream,char *buf);
int setvbuf(FILE *stream,char *buf,int type,size_t size);
```

​	这两个函数必须在流已打开后且先于其他任何操作执行之前调用。

​	`setbuf()`用于打开或关闭流 stream的缓冲。为了打开缓冲,参数`buf`必须指向一个长度为`BUFSIZ`的缓冲区。`BUFSIZ`是系统定义的宏常数,它的值至少为256。通常在此函数调用之后流将变成全缓冲的,但如果流是与终端设备相连的话,则有的系统将改变它为行缓冲的。为了关闭缓冲,参数bf必须是NULL

​	用`setvbuf()`可以明确地指定想要的缓冲类型。缓冲类型由参数type指定,它可取如下三种值之一,它们都是定义在< stdio. h>中的常数。

`_IOFBF`	全缓冲

`_IOLBF`	行缓冲

`_IONBF`	无缓冲

​	如果指定无缓冲类型,`setvbuf()`将忽略参数`buf`和size;否则`buf`和size可以任选地指定缓冲区及其大小。如果用NULL作为`buf`的值, `setvbuf()`会自动地为流分配适当大小的缓冲区。所谓适当大小是指与此流相连文件的stat结构成员`s_ blksize`指定的值。如果系统不能为流确定这个值(例如,当流与设备或管道相连时),则分配 `BUFSIZ`长度的缓冲。当流被关闭时,这样分配的缓冲区将被自动释放。否则,`buf`应当是至少能容纳size个字符的一个数组。`setvbuf()`使用此数组作为流缓冲区,并释放标准IO库原来分配的缓冲区。对于这个数组我们应当注意以下两点：

- ​	只要流是打开的,就不能释放该数组的空间。通常应当静态地分配此数组,或者用`malloc()`为它分配空间。用自动数组作为缓冲区是不好的,除非在退出说明该数组的程序块之前关闭文件。
- 流I/O函数将这个数组用于内部目的。当流正用它作为缓冲目的时,我们不能直接访问该数组的内容。

`setbuf()`实际上是`setvbuf()`的特例，它等价于

```c
setvbuf(stream,buf,buf?_IOFBF:_IONBF,BUFSIZ);
```
#### 6.2 刷新缓冲

术语刷新表示将缓冲区中的数据写出到文件中。通常,缓冲区中的数据在下述情况下会自动刷新:

1. 当流被关闭时。

2. 当调用`exit()`终止程序时。

3. 若流是行缓冲的，当写出一换行符时。

4. 当企图输出流而缓冲区已经满了时。

5. 无论何时对流的输入操作导致它实际从文件读数据时。

​	第5种情形的一个例子是:当用`printf()`输出不带换行符的个字符串至终端之后,若紧接着调用从终端读数据的函数,则也导致缓冲区的输出立即被写到终端。

​	如果想在其他时刻刷新缓冲区的内容，则要 显示地调用`fflush()`函数。

```c
#include <stdio.h>

int fflush(FILE *stream);
```

`fflush()`刷新流 stream的缓冲区。如果 stream是一空指针NULL, flush将刷新所有已打开输出流的缓冲。

### 7. 格式I/O

​	当从键盘读入用ASCII字符表示的十进制整数时,必须将它们转换成计算机可处理的二进制表示。格式I/O函数能够自动完成这种外部和内部格式之间的转换工作,并且能够对输入输出数据进行诸如数据类型、精度、位置等格式控制。

​	所有格式I/O函数都通过一个格式字符串来对其余参数进行格式描述。格式字符串中用转换区分符来描述待输入输出参数的类型、精度、外部形式以及占据的字节宽度等。掌握好转换区分符是使用格式I/O函数的关键。这一节介绍格式I/O函数,给出转换区分符的语法成分,并通过例子说明它们的用法。

#### 7.1 格式输出

​	格式输出由如下三种`printf()`函数来处理，它们是完成输出最方便的函数。

```c
#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream,const char *format, ...);
int sprintf(char *buf,const char *format, ...);
```

​	这三个函数功能相同,都在格式字符串 format的控制下输出其他参数(这里表示为“…”)。不同的只是输出的流不同: `printf()`输出至标准输出流; `fprintf()`输出至参数 stream指定的流;`sprintf()`不是输出至一个文件,而是输出至参数`buf`所指的字符数组中,并且在`buf`的末尾自动添加一个空字节。它们调用成功均返回实际输出的字符个数。








# 补充知识

标准的空白字符包括：

```c
' '     (0x20)    space (SPC) 空格符
'\t'    (0x09)    horizontal tab (TAB) 水平制表符    
'\n'    (0x0a)    newline (LF) 换行符
'\v'    (0x0b)    vertical tab (VT) 垂直制表符
'\f'    (0x0c)    feed (FF) 换页符
'\r'    (0x0d)    carriage return (CR) 回车符
```

Linux 以二进制查看文件

```console
od命令
用户通常使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。

语法：od ［选项］ 文件…
命令中各选项的含义：
- A 指定地址基数，包括：
d 十进制
o 八进制（系统默认值）
x 十六进制
n 不打印位移值
- t 指定数据的显示格式，主要的参数有：
c ASCII字符或反斜杠序列
d 有符号十进制数
f 浮点数
o 八进制（系统默认值为02）
u 无符号十进制数
x 十六进制数
```

关于`int main( int argc, char* argv[] ) `中`argc`和`argv`参数的解析及调试

[详情博客](https://blog.csdn.net/dgreh/article/details/80985928)



p

