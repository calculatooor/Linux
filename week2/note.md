# Linux编程

## 第二章 标准输入输出

### 1. UNIX输入输出基本概念

​	UNIX系统有两种机制用于描述程序与文件的这种连接:一种称为文件描述字,另一种称为流。因此,系统中关于I/O的函数也分为两大类:一类针对文件描述字操作,另一类针对流操作。

#### 1.1 文件描述字与流

​	UNIX系统中,文件描述字表示为int类型的对象,而流表示为指向类型为FILE结构的指针。文件描述字函数多数是系统调用,它们提供底层基本的输入输出操作接口。当需要对特定设备进行控制操作时,往往必须使用文件描述字,流函数不能够进行这类操作。另外,如果程序需要按特殊方式进行输入输出(如非阻塞输入),也必须使用文件描述字。

​	流函数建立在文件描述字之上,通过文件描述字函数而实现,它给程序提供了更高一级的输入输出接口。流函数比对应的文件描述字函数更丰富,功能更强大,也更利于程序的移植。任何运行 ANSI C的系统均支持流,但并不是所有系统都支持文件描述字,有的系统根本不支持文件描述字或仅仅实现了文件描述字函数集合的一个子集。因此,一般情况下,应当坚持使用流而不是文件描述字,除非是想做某种特殊操作,而此操作只能用文件描述字才能完成。

#### 1.2 文件名和路径名

​	UNIX系统中几乎每一种对象都表示为文件,不仅是通常的数据集合,系统中的每一个设备也表示为文件。文件被安排在目录中,目录本身又含有子目录,由此形成了文件系统的层次结构。

​	目录本身也是一种文件,不过它的内容是一组连接实际文件的文件名及相关信息,这些连接称为链或目录登记项。我们前面虽然说“文件被安排在目录中”,但是实际上目录只包含指向文件的指针而不是文件本身。为了理解文件名的语法,首先需要理解UNIX文件系统的目录层次结构。

​	系统中,每一个用户均有一个主目录,其文件通常存储在这个目录以及该目录的子目录中。例如,用户` kjzhao`,他的主目录是`home/ rizhao`,在其主目录中有系统帮助建立的几个标准目录,如 `bash_profile`等:也有由他自己创建的子目录,如用于日常工作的目录`work`,用于应用程序的目录 `program`等。另外一些用户的主目录也可能位于`/home`目录中,而`home`则是根目录“/”的子目录。在根目录中通常还包括用于系统程序的子目录`/bin`,用于系统配置文件的子目录`/etc`,用于系统库文件的子目录`/lib`,以及代表各种物理设备的子目录`/dev`等。图2-1是这种目录层次的一个示例图。

![](http://117.78.7.207:6789/imgs/2020/10/c69d1394fb49aeeb.png)

​	文件名用于命名一个文件,它由1至 NAME MAX个字符组成,这些字符可以是字符集中斜线字符(/)和空字符(`NUL`)之外的任意字符。系统宏 NAME_MAX是 `POSIX`定义的文件名的最大字符个数(不是字符串的长度,该计数不包括结束的空字符)。

​	文件名也称为路径名分量。路径名用于标识一个文件,它是由1至 PATH_MAX个字符组成的字符串。路径名由用斜线“/”分隔的一至多个路径名分量构成的序列组成。路径名开始的斜线是可选的,仅由一个分量构成的路径名标识一个相对于当前目录的文件,多个连续的“/”字符等价于单个“/”字符。

#### 1.2 文件位置

​	对于已打开的文件,它的属性之一是文件位置。文件位置给出文件中当前可读写字符的位置,在所有 `POSIX`兼容的系统中,它是一个表示距文件开始多少字节数的整数。

​	当文件刚打开时,文件位置位于文件的开始处,之后每当读出或者写入一个字符,文件的位置便增加一字节。换言之,对文件的访问是顺序的。

​	但是,对于以“添加”( append)打开的文件,其写出的处理有点魂对这种文件的写出总是顺序地附加在该文件的末尾,而不管文件的位置如何。其文件位置只用于控制从文件读出数据。

​	普通文件允许读写文件的任意位置。这种允许读写任意位置的文件也称为随机文件。可以用函数` fseek()`或 `lseek()`改变随机文件的位置。如果企图改变一个不支持随机访问的文件的位置,则会得到` ESPIPE`错误。磁盘文件一般均是随机文件,终端则不是随机文件。



### 2. 打开和关闭流

以下函数用于打开和关闭一个流

```C
#include <stdio.h>
FILE * fopen(const char *pathname,const char *opentype);
int fclose(FILE *stream);
FILE * freopen(const char *pathname,const char *opentype,FILE *stream);
```

​	`fopen()`打开由 pathname指定的文件并创建一个与之相连的流。如果该文件不存在,则创建一个新文件。如果打开文件成功,它返回指向此流的指针,否则返回空指针NULL。

​	`opentype`参数是一字符串,它控制文件打开的方式,其值只能是下述字符串之一:

- "r":为读而打开一个已存在的文件,文件位置定位于文件开始。

- "w":为写而打开一个文件。如果文件存在,则将它的长度截为0,也即文件将被重新写过;如果文件不存在,则创建一个新文件

- "a":为在文件尾添加内容而打开文件。若文件存在,原来的内容不变且输出添加在文件的末尾;否则,创建一个新文件。

- "r+":为更新(既读又写)而打开一个已存在的文件,文件原有内容不变,文件位置定位于文件开始。

- "w+":为更新(既读又写)而打开一个文件,若文件已存在,其长度被截至0:否则,创建一个新文件。

- "a+":为更新(既读又写)而打开一个文件,若文件已存在,原内容不变:否则,创建一个新文件。用于读的初始文件位置定位于文件开始,但输出总是添加在文件的末尾。

  其中,字母r、w和a分别代表read、 write和 append。字符“+”指明为更新而打开一个文件,当以这种方式打开一个文件时,对它既可写也可读。

打开的流用`fclose()`来关闭。`flcose()`调用成功返回0，否则返回`EOF`并置`errno`指明错误。

​	当调用` fclose()`关闭一输出流时,对错误情形进行检査很重要,因为此时可能检测到真实的错误。例如,当` fclose()`将缓冲区中剩余的数据写出时,它可能得到磁盘空间已满的错误,如果不检测的话,就有可能丢失文件的内容。

​	`freopen()`重新打开 pathname指定的文件,它的作用类似于 `fclose`()和 `fopen()`的合并。如果 stream指定的流是打开的,它首先关闭该流,忽略任何错误,然后按 `opentype`所给方式如同`fopen()`一样打开参数 pathname指定的文件,并使之与 `stream`给定的同一个流相连。 `freopen()`调用成功返回指向流的指针,否则返回NULL并置`errno`指明错误。

​	`freopen()`一般用于连接标准流 `stdin、 stdout、 stderr`至一个我们选择的文件。它对那种难以对标准流进行编程的程序很有用

### 3. 读和写流

​	一旦打开了一个流,就能对它进行读写,读写可以按无格式方式也可以按有格式方式进行。这一节介绍无格式I/O函数,下一节介绍有格式I/O函数。

​	有以下三种类型的无格式IO函数可供选择:

1)字符I/O函数。这种函数每次读或写一个字符。

2)行I/O函数。这种函数每次读写一行,每一行以换行符结束。

3)块I/O函数。这种函数支持成块IO,它们每次读写若干个对象,每个对象的大小是指定的。块IO有时也称为二进制I/O、对象O或结构IO。

#### 3.1 字符I/O流

如下三个字符输入函数每次读入一个字符：

```c
#include <stdio.h>
int fgetc(FILE * stream);
int getc(FILE * stream);
int getchar(void);
```

​	`fgetc()`从流 stream中按 unsigned char类型读取下一字符,并将它强制为int类型返回,若遇到文件结束或者出现错误,则返回`EOF`。

​	`getc()`的功能与 `fgetc()`相同,不同的是允许将 `getc()`作为宏来实现,而 `fgetc()`则必须为函数。` getc()`常常是被高度优化了的,因此是最常用的读单个字符的函数。

​	`getchar()`等价于`getc(stdin)`。

​	这三个函数之所以将流中的字符视为 unsigned char,是为了保证在其高位被设置时函数的返回值不会为负值。要求返回值为int类型是为了能够返回所有可表示的字符,不仅是ASCII字符集中的字符,也包括宽字符集中的字符,还包括遇到文件结束和错误时的指示符`EOF`。这意味着我们不能将` fgetc()`的返回值存储在字符类型的变量中。

​	与三个字符输入函数对应有如下三个字符输出函数:

```c
#include <stdio.h>
int fputc(int c,FILE *stream);
int putc(int c,FILE *stream);
int putchar(int c);
```

​	`fputc()`将字符c转换为 unsigned char类型,然后写至流 stream并返回字符c。`putc()`与 `fputc()`相同,但它常常是用较快的宏来实现的。 `putc()`是用于输出单个字符最合适的函数。类似于输入函数, `putchar()`等价于`putc(stdin)`

p45

p48









p